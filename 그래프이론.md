# ê·¸ë˜í”„(Graph)

## ì–‘ë°©í–¥(ë¬´ë°©í–¥)

### ğŸ’œ DFS

- Recursive
- ë°©ë¬¸ ì—¬ë¶€ í™•ì¸ì„ ìœ„í•œ visited[] ë°°ì—´ ì´ìš©
```java
public static int n, m;
public static int [][] graph;
public static boolean [][] visited;

public static boolean dfs(int x, int y) {

    if(x < 0 || x >= n || y < 0 || y >= m)
        return false;

    if(!visited[x][y] && graph[x][y]==0) {
        visited[x][y] = true;
        dfs(x+1, y);
        dfs(x-1, y);
        dfs(x, y+1);
        dfs(x, y-1);
        return true;
    }

    return false;
}
```

### ğŸ’œ BFS

- Queue
- ë°©ë¬¸ ì—¬ë¶€ í™•ì¸ì„ ìœ„í•œ visited[] ë°°ì—´ ì´ìš©

```java
public static int n, m;
public static int [][] graph;
public static boolean [][] visited;
public static int [] dx = {1, 0, -1, 0};
public static int [] dy = {0, 1, 0, -1};

static class Point {...}

public static void bfs(int x, int y) {

    Queue<Point> q = new LinkedList<>();

    q.offer(new Point(x, y));
    visited[x][y] = true;

    while(!q.isEmpty()) {

        Point now = q.poll();
        int cx = now.getX();
        int cy = now.getY();

        for(int i=0; i<4; i++) {

            int nx = cx + dx[i];
            int ny = cy + dy[i];

            if( nx<0 || nx>=n || ny<0 || ny>=m )
                continue;

            if(!visited[nx][ny] && graph[nx][ny]==0) {
                visited[nx][ny] = true;
                q.offer(new Point(nx, ny));
            }
        }
    }
}
```

### ğŸ’œ Kruskal Algorithm

- ê°„ì„ ì„ ë¹„ìš© ìˆœìœ¼ë¡œ ì •ë ¬ í›„ ëª¨ë“  ê°„ì„ ì„ í™•ì¸
- Cycleì´ ì•„ë‹Œ ê°„ì„ ì˜ ê²½ìš°ë¡œë§Œ êµ¬ì„± => `ìœ ë‹ˆì˜¨íŒŒì¸ë“œ`ë¡œ Cycle íŒë³„
  - ë” í° ë£¨íŠ¸ ë…¸ë“œê°€ ë” ì‘ì€ ë£¨íŠ¸ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë„ë¡ í•˜ëŠ” ê²ƒì´ ê´€í–‰
```java
public static int [] parent;

public static int findParent(int x){
  if(x==parent[x])
    return x;
  
  return parent[x] = findParent(int parent[x]);
}

public static void unionParent(int a, int b){
  a = findParent(a);
  b = findParent(b);
  
  if(a<b)
    parent[b] = a;
  else
    parent[a] = b;
}
```
- Kruskal Algorithm ìˆ˜í–‰ í›„ => ê°„ì„ ì˜ ìˆ˜ = ë…¸ë“œì˜ ìˆ˜ - 1
```java
public static int v, e; //v: ë…¸ë“œì˜ ê°œìˆ˜, e: ê°„ì„ ì˜ ê°œìˆ˜
public static List<Edge> edges = new ArrayList<>();
public static int result = 0;

static class Edge implements Comparable<Edge> {
  
  private int nodeA;
  private int nodeB;
  private int distance;
  
  ...
  public int compareTo(Edge o){
    return this.distance < o.distance ? -1 : 1 ;
  }
}

public static void main(String[] args) {

  //parent ë°°ì—´ ìê¸°ìì‹ ìœ¼ë¡œ ì´ˆê¸°í™”
  for(int i=1; i<=v; i++)
    parent[i] = i;
    
  //ê°„ì„ ì •ë³´ê°€ ë‹´ê¸´ edges ì…ë ¥ë°›ê¸°
  ...
  
  //ì…ë ¥ë°›ì€ ê°„ì„ ì •ë³´ì— ëŒ€í•˜ì—¬, ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬
  Collections.sort(edges);
  
  //ê°„ì„ ì„ í™•ì¸í•˜ë©´ì„œ
  for(int i=0; i<e; i++) {
    int a = edges.get(i).getNodeA();
    int b = edges.get(i).getNodeB();
    int cost = edges.get(i).getDistance();
    
    //ì‚¬ì´í´ì´ ì•„ë‹Œ ê°„ì„  ì •ë³´ë§Œ ê°€ì ¸ê°
    if(findParent(a)!=findParent(b)) {
      unionParent(a,b);
      result += cost;
    }
  }
}
```

## ë‹¨ë°©í–¥

### ğŸ’œ Dijkstra Algorithm

- Priority Queue, ì¸ì ‘ë¦¬ìŠ¤íŠ¸
- ìµœë‹¨ ê±°ë¦¬ ê¸°ë¡í•˜ê¸° ìœ„í•œ d[] í–‰ë ¬ ì´ìš©, ì´ˆê¸° ê°’ INFë¡œ ì±„ì›€
```java
public static final int INF = (int) 1e9;
public static List<ArrayList<Node>> graph = new ArrayList<>();
public static int [] d;
    
static class Node implements Comparable<Node> {

    private final int node;
    private final int distance;

    ...
    
    public int compareTo(Node o){
        return this.distance < o.distance ? -1 : 1;
    }
}

public static void dijkstra(int start) {

    Queue<Node> pq = new PriorityQueue<>();

    Arrays.fill(d, INF);

    pq.offer(new Node(start, 0));
    d[start] = 0;

    while(!pq.isEmpty()) {

        Node node = pq.poll();
        int now = node.getNode();
        int distance = node.getDistance();

        if(d[now] < distance)
            continue;

        //í˜„ì¬ ë…¸ë“œì— ì—°ê²° ëœ ê±°ë¦¬ í™•ì¸
        for(int i=0; i<graph.get(now).size(); i++){

            int index = graph.get(now).get(i).getNode();
            int cost = d[now] + graph.get(now).get(i).getDistance();

            if(cost < d[index]) {
                d[index] = cost;
                pq.offer(new Node(index, cost));
            }
        }
    }
}
```

### ğŸ’œ Bellman Ford Algorithm

- ìŒì˜ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§ˆ ë•Œ, ì¸ì ‘ë¦¬ìŠ¤íŠ¸ 
- ë…¸ë“œì™€ ê°„ì„ ì˜ ê°œìˆ˜ë§Œí¼ ë°˜ë³µ(2 ì¤‘ forë¬¸)
- ìµœë‹¨ ê±°ë¦¬ ê¸°ë¡í•˜ê¸° ìœ„í•œ d[] í–‰ë ¬ ì´ìš©, ì´ˆê¸° ê°’ INFë¡œ ì±„ì›€
```java
public static final int INF = (int) 1e9;
public static int v, e; //v: ë…¸ë“œì˜ ê°œìˆ˜, e: ê°„ì„ ì˜ ê°œìˆ˜
public static List<Node> graph = neew ArrayList<>();
public static int d [];

static class Node {
  private int from;
  private int to;
  private int distance;
}

public static boolean bellmanFord(int start) {

  Arrays.fill(d, INF);
  d[start] = 0;
  
  //ë…¸ë“œì˜ ê°œìˆ˜ë§Œí¼ ë°˜ë³µ
  for(int i=1; i<=v; i++){
    //ê°„ì„ ì˜ ê°œìˆ˜ë§Œí¼ ë°˜ë³µ
    for(int j=0; j<e; j++) {
      Node node = graph.get(j);
      
      //from->to ê°ˆë•Œ, fromì´ INFì´ë©´ ê°ˆ ìˆ˜ ì—†ìŒ
      if(d[node.getFrom()] == INF)
        continue;
        
      if(d[node.getFrom()] + node.getCost() < d[node.getTo()]) {
      
        //ë§ˆì§€ë§‰ ë…¸ë“œì—ì„œ ê°’ì˜ ê°±ì‹ ì´ ì¼ì–´ë‚˜ë©´ ìŒì˜ cycleì¡´ì¬
        if(i==v)
          return false;
      
        d[node.getTo()] = d[node.getFrom()] + node.getCost();
      }
    }
  }
  return true;
}
```

### ğŸ’œ Floyd Warshall Algorithm

- ì¸ì ‘ í–‰ë ¬ ì´ìš©
- D_ab = min(D_ab, D_ak + D_kb) (3 ì¤‘ forë¬¸)
- ë³´í†µ ë…¸ë“œ ê°œìˆ˜ê°€ 500 ê°œ ì´í•˜ì¼ ë•Œ ì‚¬ìš©

```java
public static final int INF = (int) 1e9;

public static void main(String[] args) {

  int n, m; //n: ë…¸ë“œì˜ ìˆ˜, m: ê°„ì„ ì˜ ìˆ˜
  int [][] graph = new int [n+1][n+1];
  
  //graph ì´ˆê¸°í™”
  for(int i=0; i<=n; i++)
    Arrays.fill(graph[i], INF);
    
  for (int i=0; i<=n; i++)
    for (int j=0; j<=n; j++)
      if(i==j) graph[i][j] = 0;

  // ê°„ì„ ì •ë³´ ì…ë ¥ (í–‰ì´ ì¶œë°œ, ì—´ì´ ë„ì°©)
  ...
  
  // ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰
  for(k=1; i<=n; k++) 
    for(a=1; a<=n; a++)
      for(b=1; b<=n; b++)
        graph[a][b] = Math.min(graph[a][b], graph[a][k]+graph[k][b]);
        
}
```
