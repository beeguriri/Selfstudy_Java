## 서로소 집합
- 공통 원소가 없는 두 집합
- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- 합집합 : 두개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
- 찾기 : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
- `합치기 찾기(Uion Find)` 자료구조 
> {1} {2} {3} {4} {5} {6} 이 있을 때,  
초기 : 서로 다른 집합으로 분류, 부모가 자기 자신     
Union(1,4) => 1번 노드의 부모 1, 4번 노드의 부모 1  
Union(2,3) => 2번 노드의 부모 2, 3번 노드의 부모 2  
Union(2,4) => `2번 노드의 부모 1`, 4번 노드의 부모 1  
Union(5,6) => 5번 노드의 부모 5, 6번 노드의 부모 6  
- 더 큰 루트노드가 더 작은 루트노드를 가르키도록 하는 것이 관행
- 연결성을 통해 집합의 형태 확인
- 루트 노드를 찾기위해 부모 테이블을 계속해서 확인해서 거슬러 올라감 (루트 노드 즉시 접근X)
```java
//특정 원소가 속한 집합을 찾기
//루트노드 찾을때 까지 재귀 호출
findParent(){
    
        }
//두 원소가 속한 집합을 합치기
unionParent(){
    //각각의 루트번호를 찾은 후
    //루트번호가 큰쪽이 작은쪽을 가르키도록 함.
        }
```
### 사이클 판별 알고리즘
- 무방향  그래프 내에서 사이클 판별
- (참고: 방향 그래프에서 사이클 여부는 DFS를 통해 판별)
- 각 간선을 하나씩 확인하며 두 노드의 루트노드 확인
  - 루트 노드가 서로 다르면 합집합 연산 수행
  - 같으면 사이클 발생


## 신장트리
- 그래프에서 모든 노드를 포함하면서 `사이클이 존재하지 않는` 부분 그래프
- ex) 최소비용으로 전체 도시가 연결될 수 있게 하는 경우

### 크루스칼 알고리즘
- 간선 데이터를 `비용에 따라 오름차순`으로 정렬
- 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
  - 사이클 발생 여부는 서로소집합 활용 
  - 사이클이 발생하지 않으면 최소신장트리에 포함
- 알고리즘 수행 완료 수 간선의 개수 = 노드의개수 - 1

## 위상정렬
- 방향그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열
  - 사이클이 없는 방향그래프여야 함!
  - 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판별
- 진입차수가 0인 모든 노드를 큐에 넣음
- 큐가 빌때까지
  - 큐에서 원소를 꺼내서 해당 노드에서 나가는 간선을 그래프에서 제거
  - 새롭게 진입차수가 0이 된 노드를 큐에 넣음
- 위상정렬 수행 결과: 각 노드가 큐에 들어온 순서